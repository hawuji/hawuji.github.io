[{"title":"（转载）JavaScript 常用 API 合集01-节点","date":"2017-03-14T14:37:00.000Z","path":"2017/03/14/JavaScript-常用-API-合集01-节点/","text":"一、节点1.1 节点属性 API 功能说明 Node.nodeName //返回节点名称，只读 Node.nodeType //返回节点类型的常数值，只读 Node.nodeValue //返回 Text 或 Comment 节点的文本值，只读 Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写 Node.baseURI //返回当前网页的绝对路径 Node.ownerDocument //返回当前节点所在的顶层文档对象，即 document Node.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点 Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点 Node.parentNode //返回当前节点的父节点 Node.parentElement //返回当前节点的父 Element 节点 Node.childNodes //返回当前节点的所有子节点 Node.firstChild //返回当前节点的第一个子节点 Node.lastChild //返回当前节点的最后一个子节点 //parentNode 接口 – Node.children //返回指定节点的所有 Element 子节点 Node.firstElementChild //返回当前节点的第一个 Element 子节点 Node.lastElementChild //返回当前节点的最后一个 Element 子节点 Node.childElementCount //返回当前节点所有 Element 子节点的数目。 1.2 操作 API 功能说明 Node.appendChild(node) //向节点添加最后一个子节点 Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点 Node.cloneNode(true); // 默认为 false(克隆节点), true(克隆节点及其属性，以及后代) Node.insertBefore(newNode,oldNode) // 在指定子节点之前插入新的子节点 Node.removeChild(node) //删除节点，在要删除节点的父节点上操作 Node.replaceChild(newChild,oldChild) //替换节点 Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点。 Node.compareDocumentPosition(node) //返回一个 7 个比特位的二进制值，表示参数节点和当前节点的关系 Node.isEqualNode(noe) //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。 Node.normalize() //用于清理当前节点内部的所有 Text 节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。 //ChildNode 接口 — Node.remove() //用于删除当前节点 Node.before() // Node.after() // Node.replaceWith() // 1.3 Document 节点1.3.1 Document 节点的属性 API 功能说明 document.doctype // document.documentElement //返回当前文档的根节点 document.defaultView //返回 document 对象所在的 window 对象 document.body //返回当前文档的节点 document.head //返回当前文档的节点 document.activeElement //返回当前文档中获得焦点的那个元素。 //节点集合属性 – document.links //返回当前文档的所有 a 元素 document.forms //返回页面中所有表单元素 document.images //返回页面中所有图片元素 document.embeds //返回网页中所有嵌入对象 document.scripts //返回当前文档的所有脚本 document.styleSheets //返回当前网页的所有样式表 //文档信息属性 – document.documentURI //表示当前文档的网址 document.URL //返回当前文档的网址 document.domain //返回当前文档的域名 document.lastModified //返回当前文档最后修改的时间戳 document.location //返回 location 对象，提供当前文档的 URL 信息 document.referrer //返回当前文档的访问来源 document.title //返回当前文档的标题 document.characterSet // 属性返回渲染当前文档的字符集，比如 UTF-8、ISO-8859-1。 document.readyState //返回当前文档的状态 document.designMode //控制当前文档是否可编辑，可读写 document.compatMode //返回浏览器处理文档的模式 document.cookie //用来操作 Cookie 1.3.2 Document 节点的方法（1）读写方法 API 功能说明 document.open() //用于新建并打开一个文档 document.close() //不安比 open 方法所新建的文档 document.write() //用于向当前文档写入内容 document.writeIn() //用于向当前文档写入内容，尾部添加换行符。 （2）查找节点 API 功能说明 document.querySelector(selectors) //接受一个 CSS 选择器作为参数，返回第一个匹配该选择器的元素节点。 document.querySelectorAll(selectors) //接受一个 CSS 选择器作为参数，返回所有匹配该选择器的元素节点。 document.getElementsByTagName(tagName) //返回所有指定 HTML 标签的元素 document.getElementsByClassName(className) //返回包括了所有 class 名字符合指定条件的元素 document.getElementsByName(name) //用于选择拥有 name 属性的 HTML 元素（ 比如&lt;form>、&lt;radio>、&lt;img>、&lt;frame>、&lt;embed>和&lt;object>等） document.getElementById(id) //返回匹配指定 id 属性的元素节点。 document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element 子节点。 （3）生成节点 API 功能说明 document.createElement(tagName) //用来生成 HTML 元素节点。 document.createTextNode(text) //用来生成文本节点 document.createAttribute(name) //生成一个新的属性对象节点，并返回它。 document.createDocumentFragment() //生成一个 DocumentFragment 对象 （4）事件方法 API 功能说明 document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用 document.addEventListener(type,listener,capture) //注册事件 document.removeEventListener(type,listener,capture) //注销事件 document.dispatchEvent(event) //触发事件 （5）其他 API 功能说明 document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。 document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。 document.importNode(externalNode, deep) //从外部文档拷贝指定节点，插入当前文档。 1.4 Element 节点1.4.1 Element 节点的属性（1）特性属性 API 功能说明 Element.attributes //返回当前元素节点的所有属性节点 Element.id //返回指定元素的 id 属性，可读写 Element.tagName //返回指定元素的大写标签名 Element.innerHTML //返回该元素包含的 HTML 代码，可读写 Element.outerHTML //返回指定元素节点的所有 HTML 代码，包括它自身和包含的的所有子元素，可读写 Element.className //返回当前元素的 class 属性，可读写 Element.classList //返回当前元素节点的所有 class 集合 Element.dataset //返回元素节点中所有的 data-*属性。 （2）尺寸属性 API 功能说明 Element.clientHeight //返回元素节点可见部分的高度 Element.clientWidth //返回元素节点可见部分的宽度 Element.clientLeft //返回元素节点左边框的宽度 Element.clientTop //返回元素节点顶部边框的宽度 Element.scrollHeight //返回元素节点的总高度 Element.scrollWidth //返回元素节点的总宽度 Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置 Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值 Element.offsetHeight //返回元素的垂直高度(包含 border,padding) Element.offsetWidth //返回元素的水平宽度(包含 border,padding) Element.offsetLeft //返回当前元素左上角相对于 Element.offsetParent节点的垂直偏移 Element.offsetTop //返回水平位移 Element.style //返回元素节点的行内样式 （3）节点相关属性 API 功能说明 Element.children //包括当前元素节点的所有子元素 Element.childElementCount //返回当前元素节点包含的子 HTML 元素节点的个数 Element.firstElementChild //返回当前节点的第一个 Element 子节点 Element.lastElementChild //返回当前节点的最后一个 Element 子节点 Element.nextElementSibling //返回当前元素节点的下一个兄弟 HTML 元素节点 Element.previousElementSibling //返回当前元素节点的前一个兄弟 HTML 节点 Element.offsetParent //返回当前元素节点的最靠近的、并且 CSS 的position 属性不等于 static 的父元素。 1.4.2 Element 节点的方法（1）位置方法 API 功能说明 getBoundingClientRect() // getBoundingClientRect 返回一个对象，包含top,left,right,bottom,width,height getBoundingClientRect().top // top 元素上外边界距窗口最上面的距离 getBoundingClientRect().right // right 元素右外边界距窗口最上面的距离 getBoundingClientRect().bottom // bottom 元素下外边界距窗口最上面的距离 getBoundingClientRect().left // left 元素左外边界距窗口最上面的距离 getBoundingClientRect().width // width 元素自身宽(包含 border,padding) getBoundingClientRect().height // height 元素自身高(包含 border,padding) getClientRects() //返回当前元素在页面上形参的所有矩形。 元素在页面上的偏移量12345var rect = el.getBoundingClientRect()return &#123; top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft&#125; （2）属性方法 API 功能说明 Element.getAttribute() //读取指定属性 Element.setAttribute() //设置指定属性 Element.hasAttribute() //返回一个布尔值，表示当前元素节点是否有指定的属性 Element.removeAttribute() //移除指定属性 （3）查找方法 API 功能说明 Element.querySelector() //返回匹配指定选择器的第一个元素 Element.querySelectorAll() //返回所有满足条件的元素，结果是个nodeList集合 Element.getElementsByTagName() //返回带有指定标签名的对象的集合 Element.getElementsByClassName() //返回文档中所有指定类名的元素集合，作为 NodeList 对象。 （4）事件方法 API 功能说明 Element.addEventListener() //添加事件的回调函数 Element.removeEventListener() //移除事件监听函数 Element.dispatchEvent() //触发事件 //ie8Element.attachEvent(oneventName,listener)Element.detachEvent(oneventName,listener) // event 对象var event = window.event||event; // 事件的目标节点var target = event.target || event.srcElement; // 事件代理12345ul.addEventListener('click', function(event) &#123; if (event.target.tagName.toLowerCase() === 'li') &#123; console.log(event.target.innerHTML) &#125;&#125;); （5）其他Element.scrollIntoView() //滚动当前元素，进入浏览器的可见区域解析 HTML 字符串，然后将生成的节点插入 DOM 树的指定位置。Element.insertAdjacentHTML(where, htmlString);Element.insertAdjacentHTML(‘beforeBegin’, htmlString); // 在该元素前插入Element.insertAdjacentHTML(‘afterBegin’, htmlString); // 在该元素第一个子元素前插入Element.insertAdjacentHTML(‘beforeEnd’, htmlString); // 在该元素最后一个子元素后面插入Element.insertAdjacentHTML(‘afterEnd’, htmlString); // 在该元素后插入Element.remove() //用于将当前元素节点从 DOM 中移除Element.focus() //用于将当前页面的焦点，转移到指定元素上 本文转载自 web前端开发 公众号,大家可以关注此公众号回复关键字“jsapi”进行获取此电子版文档。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.hawuji.com/tags/JavaScript/"},{"name":"转载","slug":"转载","permalink":"http://blog.hawuji.com/tags/转载/"},{"name":"API","slug":"API","permalink":"http://blog.hawuji.com/tags/API/"}]},{"title":"JavaScript设计模式与开发实践学习笔记02","date":"2017-03-06T16:08:48.000Z","path":"2017/03/07/JavaScript设计模式与开发实践学习笔记02/","text":"第二章 this、call和applyJavaScript 的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 作为对象的方法调用 作为普通函数调用。 构造器调用。 Function.prototype.call 或 Function.prototype.apply 调用。 在普通函数方式中this总是指向全局对象，在浏览器的 JavaScript 里，这个全局对象是 window 对象，如下代码：123456789window.name = 'globalName';var myObject = &#123; name: 'sven', getName: function()&#123; return this.name; &#125;&#125;;var getName = myObject.getName;console.log( getName() ); // globalName 在 ECMAScript 5 的 strict 模式下，这种情况下的 this 已经被规定为不会指向全局对象，而是 undefined在构造器调方式用中使用this，通常this会返回这个对象，但如果是的返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，记住是显示的返回object类型的对象，其他的非对象类型的返回不受影响，如下面两段代码：12345678var MyClass = function()&#123; this.name = 'sven'; return &#123; // 显式地返回一个对象 name: 'anne' &#125;&#125;;var obj = new MyClass();alert ( obj.name ); // 输出： anne 123456var MyClass = function()&#123;this.name = 'sven'return 'anne'; // 返回 string 类型&#125;;var obj = new MyClass();alert ( obj.name ); // 输出： sven 上面的两段代码中一个是返回的对象，最后输出的是这个对象，另一段代码返回的是字符型的，最后输出不受影响。 当使用 Function.prototype.call 或 Function.prototype.apply 调用时，this会指向由call或apply连接的上下文。下面是一段在考察this使用时经常出现的代码123456789var obj = &#123; myName: 'sven', getName: function()&#123; return this.myName; &#125;&#125;;console.log( obj.getName() ); // 输出： 'sven'var getName2 = obj.getName;console.log( getName2() ); // 输出： undefined 之所以出现两种不同的输出是因为当调用 obj.getName 时， getName 方法是作为 obj 对象的属性被调用的，此时的 this 指向 obj 对象，所以 obj.getName()输出’sven’。当用另外一个变量 getName2 来引用 obj.getName，并且调用 getName2 时，此时是普通函数调用方式， this 是指向全局 window 的，所以程序的执行结果是 undefined。 关于call和apply的区别也是烂大街的问题了。它们的作用都是将函数绑定到另外一个对象上去运行，两者仅在定义参数方式有所区别。apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组。call：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。12345var func = function( a, b, c )&#123; alert ( [ a, b, c ] ); // 输出 [ 1, 2, 3 ]&#125;;func.apply( null, [ 1, 2, 3 ] );func.call( null, 1, 2, 3 ); 使用call修正this的场景，观察下面两段代码：1234567document.getElementById( 'div1' ).onclick = function()&#123; alert( this.id ); // 输出： div1 var func = function()&#123; alert ( this.id ); // 输出： undefined &#125; func();&#125;; 123456document.getElementById( 'div1' ).onclick = function()&#123; var func = function()&#123; alert ( this.id ); // 输出： div1 &#125; func.call( this );&#125;; Function.prototype.bind大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this指向。模拟实现一个bind函数12345678910111213Function.prototype.bind = function( context )&#123; var self = this; // 保存原函数 return function()&#123; // 返回一个新的函数 return self.apply( context, arguments ); // 执行新的函数的时候，会把之前传入的 context当作新函数体内的 this &#125;&#125;;var obj = &#123; name: 'sven'&#125;;var func = function()&#123; alert ( this.name ); // 输出： sven&#125;.bind( obj);func(); 为了可以向func函数中传入一些参数，就要对bind进行修改：123456789101112131415161718Function.prototype.bind = function()&#123; var self = this, // 保存原函数 context = [].shift.call( arguments ), // 需要绑定的 this 上下文 args = [].slice.call( arguments ); // 剩余的参数转成数组 return function()&#123; // 返回一个新的函数 return self.apply( context, [].concat.call( args, [].slice.call( arguments ) ) ); // 执行新的函数的时候，会把之前传入的 context 当作新函数体内的 this // 并且组合两次分别传入的参数，作为新函数的参数 &#125;&#125;;var obj = &#123; name: 'sven'&#125;;var func = function( a, b, c, d )&#123;alert ( this.name ); // 输出： svenalert ( [ a, b, c, d ] ) // 输出： [ 1, 2, 3, 4 ]&#125;.bind( obj, 1, 2 );func( 3, 4 ); 总结this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。为了修正this的指向，可以使用call、apply来改变上下文，同时，call、apply也是对对象的一种扩展。 apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.hawuji.com/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.hawuji.com/tags/设计模式/"}]},{"title":"JavaScript设计模式与开发实践学习笔记01","date":"2017-03-04T15:47:49.000Z","path":"2017/03/04/JavaScript设计模式与开发实践学习笔记01/","text":"第一章 面向对象的JavaScriptJavaScript是一门典型的动态类型语言，简单的理解动态类型编程语言就是变量的数据类型是不确定的，只有当程序运行到当前变量时才确定变量的类型。比如 var a = 123; 此时123既可能是string类型，也可能是number类型，只有在运行到a变量时才根据程序环境进行判断。 多态：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与 “可能改变的事物”分离开来。一段简单的多态代码1234567891011var makeSound = function( animal )&#123; if ( animal instanceof Duck )&#123; console.log( '嘎嘎嘎' ); &#125;else if ( animal instanceof Chicken )&#123; console.log( '咯咯咯' ); &#125;&#125;;var Duck = function()&#123;&#125;;var Chicken = function()&#123;&#125;;makeSound( new Duck() ); // 嘎嘎嘎makeSound( new Chicken() ); // 咯咯咯 上面这段代码实现了一个简单的多态，同一个函数传入不同的参数后输入不同的结果，但这段代码的问题在于如果要新加入一个不同的参数的话，函数maskSound就要扩充，当参数的种类越来越多时，maskSound函数也就变得越来越复杂。如：现在要加入一个dog参数，则makdSound函数就要再时行判断了。改进代码：12345678910111213var makeSound = function( animal )&#123; animal.sound();&#125;;var Duck = function()&#123;&#125;Duck.prototype.sound = function()&#123; console.log( '嘎嘎嘎' );&#125;;var Chicken = function()&#123;&#125;Chicken.prototype.sound = function()&#123; console.log( '咯咯咯' );&#125;;makeSound( new Duck() ); // 嘎嘎嘎makeSound( new Chicken() ); // 咯咯咯 如果此时要加入一个Dog则只需加入如下代码：12345var Dog = function()&#123;&#125;Dog.prototype.sound = function()&#123; console.log( '汪汪汪' );&#125;;makeSound( new Dog() ); // 汪汪汪 通过上面的两段代码就充分体现了多态背后的思想：将“做什么”和“谁去做以及怎样去做”分离开。 理解面向对象程序设计的多态，书中给出一个非常形象的比喻： 在电影的拍摄现场，当导演喊出“ action”时，主角开始背台词，照明师负责打灯光，后面的群众演员假装中枪倒地，道具师往镜头里撒上雪花。在得到同一个消息时，每个对象都知道自己应该做什么。 在程序设计中相似的例子，调用地图API，有时可能要调用谷歌地图，也有可能调用百度地图，如下的renderMap函数：12345678910111213141516171819var googleMap = &#123; show: function()&#123; console.log( '开始渲染谷歌地图' ); &#125;&#125;;var baiduMap = &#123; show: function()&#123; console.log( '开始渲染百度地图' ); &#125;&#125;;var renderMap = function( type )&#123; if ( type === 'google' )&#123; googleMap.show(); &#125;else if ( type === 'baidu' )&#123; baiduMap.show(); &#125;&#125;;renderMap( 'google' ); // 输出：开始渲染谷歌地图renderMap( 'baidu' ); // 输出：开始渲染百度地图 上面的函数固然达到了多态的效果，但还是没有把多态的思想表达出来，如果此时要再加一个搜狗地图的话，又要修改renderMap函数了，因此还要修改这个renderMap函数，以达到更灵活的目的：1234567var renderMap = function( map )&#123; if ( map.show instanceof Function )&#123; map.show(); &#125;&#125;;renderMap( googleMap ); // 输出：开始渲染谷歌地图renderMap( baiduMap ); // 输出：开始渲染百度地图 如果此时加入一个搜狗地图刚只需添加123456var sosoMap = &#123; show: function()&#123; console.log( '开始渲染搜搜地图' ); &#125;&#125;;renderMap( sosoMap ); // 输出：开始渲染搜搜地 封装：在一些面向对象的高级语言中会用一些关键词如：private、public、 protected来实现数据的访问权限，但在JS中并没有这样的关键词去实现数据的封装，但可以通过函数来创建作用域。 原型模式实现关键，是语言本身是否提供了 clone 方法。ECMAScript 5 提供了 Object.create方法，可以用来克隆对象。代码如下：1234567891011var Plane = function()&#123; this.blood = 100; this.attackLevel = 1; this.defenseLevel = 1;&#125;;var plane = new Plane();plane.blood = 500;plane.attackLevel = 10;plane.defenseLevel = 7;var clonePlane = Object.create( plane );console.log( clonePlane ); // 输出： Object &#123;blood: 500, attackLevel: 10, defenseLevel: 7&#125; 在不支持 Object.create 方法的浏览器中，则可以使用以下代码：12345Object.create = Object.create || function( obj )&#123; var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125; 原型链：现在有一个根对象：Object,Object 是 Animal 的原型，而 Animal 是 Dog 的原型,这样他们之间就形成了一个原型链，当我们调用Dog中的某个方法时会先在Dog对象中寻找，如果Dog对象中没有则继续顺着原型链去Animal中寻到，如果还是没有刚继续到Object中寻找，如果找到刚返回，如果没有则返回null。 所有的数据都是对象。 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。 对象会记住它的原型。 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。 ECMAScript 有 5 种原始类型（primitive type），即 Undefined、Null、Boolean、Number 和 String、Symbol（ES6新加的） 。基本类型包括 undefined、 number、 boolean、 string、 function、 object。 JavaScript 中的根对象是 Object.prototype 对象。 Object.prototype 对象是一个空的对象。我们在 JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的，Object.prototype 对象就是它们的原型。 1234var obj1 = new Object();var obj2 = &#123;&#125;;console.log( Object.getPrototypeOf( obj1 ) === Object.prototype ); // 输出： trueconsole.log( Object.getPrototypeOf( obj2 ) === Object.prototype ); // 输出： true JavaScript 给对象提供了一个名为__proto__的隐藏属性，某个对象的__proto__属性默认会指向它的构造器的原型对象，即{Constructor}.prototype。面的代码是我们最常用的原型继承方式：123456var A = function()&#123;&#125;;A.prototype = &#123; name: 'sven' &#125;;var B = function()&#123;&#125;;B.prototype = new A();var b = new B();console.log( b.name ); // 输出： sven 上面的代码中js引擎工作步骤如下： 首先，尝试遍历对象 b 中的所有属性，但没有找到 name 这个属性 查找 name 属性的请求被委托给对象 b 的构造器的原型，它被 b.__proto__ 记录着并且指向B.prototype，而 B.prototype 被设置为一个通过 new A()创建出来的对象。 在该对象中依然没有找到 name 属性，于是请求被继续委托给这个对象构造器的原型A.prototype。 在 A.prototype 中找到了 name 属性，并返回它的值。 以上就形成了一个原型链。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.hawuji.com/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.hawuji.com/tags/设计模式/"},{"name":"原型模式","slug":"原型模式","permalink":"http://blog.hawuji.com/tags/原型模式/"}]},{"title":"Hexo入门介绍","date":"2017-01-10T13:01:34.000Z","path":"2017/01/10/hello-world/","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 使用方法创建一篇新文章可以执行下列命令来创建一篇新文章。1$ hexo new \"My New Post\" 查看文档: 写作 启动本地服务1$ hexo server Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用，查看文档: 服务器 生成文件1$ hexo generate 使用 Hexo 生成静态文件查看文档: 生成文件 一键部署1$ hexo deploy Hexo 提供了快速方便的一键部署功能，只需一条命令就能将网站部署到服务器上。查看文档: 部署","tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.hawuji.com/tags/hexo/"}]}]