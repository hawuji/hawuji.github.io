[{"title":"JavaScript设计模式与开发实践学习笔记02","date":"2017-03-06T16:08:48.000Z","path":"2017/03/07/JavaScript设计模式与开发实践学习笔记02/","text":"第二章 this、call和applyJavaScript 的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 作为对象的方法调用 作为普通函数调用。 构造器调用。 Function.prototype.call 或 Function.prototype.apply 调用。 在普通函数方式中this总是指向全局对象，在浏览器的 JavaScript 里，这个全局对象是 window 对象，如下代码：123456789window.name = 'globalName';var myObject = &#123; name: 'sven', getName: function()&#123; return this.name; &#125;&#125;;var getName = myObject.getName;console.log( getName() ); // globalName 在 ECMAScript 5 的 strict 模式下，这种情况下的 this 已经被规定为不会指向全局对象，而是 undefined在构造器调方式用中使用this，通常this会返回这个对象，但如果是的返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，记住是显示的返回object类型的对象，其他的非对象类型的返回不受影响，如下面两段代码：12345678var MyClass = function()&#123; this.name = 'sven'; return &#123; // 显式地返回一个对象 name: 'anne' &#125;&#125;;var obj = new MyClass();alert ( obj.name ); // 输出： anne 123456var MyClass = function()&#123;this.name = 'sven'return 'anne'; // 返回 string 类型&#125;;var obj = new MyClass();alert ( obj.name ); // 输出： sven 上面的两段代码中一个是返回的对象，最后输出的是这个对象，另一段代码返回的是字符型的，最后输出不受影响。 当使用 Function.prototype.call 或 Function.prototype.apply 调用时，this会指向由call或apply连接的上下文。下面是一段在考察this使用时经常出现的代码123456789var obj = &#123; myName: 'sven', getName: function()&#123; return this.myName; &#125;&#125;;console.log( obj.getName() ); // 输出： 'sven'var getName2 = obj.getName;console.log( getName2() ); // 输出： undefined 之所以出现两种不同的输出是因为当调用 obj.getName 时， getName 方法是作为 obj 对象的属性被调用的，此时的 this 指向 obj 对象，所以 obj.getName()输出’sven’。当用另外一个变量 getName2 来引用 obj.getName，并且调用 getName2 时，此时是普通函数调用方式， this 是指向全局 window 的，所以程序的执行结果是 undefined。 关于call和apply的区别也是烂大街的问题了。它们的作用都是将函数绑定到另外一个对象上去运行，两者仅在定义参数方式有所区别。apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组。call：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。12345var func = function( a, b, c )&#123; alert ( [ a, b, c ] ); // 输出 [ 1, 2, 3 ]&#125;;func.apply( null, [ 1, 2, 3 ] );func.call( null, 1, 2, 3 ); 使用call修正this的场景，观察下面两段代码：1234567document.getElementById( 'div1' ).onclick = function()&#123; alert( this.id ); // 输出： div1 var func = function()&#123; alert ( this.id ); // 输出： undefined &#125; func();&#125;; 123456document.getElementById( 'div1' ).onclick = function()&#123; var func = function()&#123; alert ( this.id ); // 输出： div1 &#125; func.call( this );&#125;; Function.prototype.bind大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this指向。模拟实现一个bind函数12345678910111213Function.prototype.bind = function( context )&#123; var self = this; // 保存原函数 return function()&#123; // 返回一个新的函数 return self.apply( context, arguments ); // 执行新的函数的时候，会把之前传入的 context当作新函数体内的 this &#125;&#125;;var obj = &#123; name: 'sven'&#125;;var func = function()&#123; alert ( this.name ); // 输出： sven&#125;.bind( obj);func(); 为了可以向func函数中传入一些参数，就要对bind进行修改：123456789101112131415161718Function.prototype.bind = function()&#123; var self = this, // 保存原函数 context = [].shift.call( arguments ), // 需要绑定的 this 上下文 args = [].slice.call( arguments ); // 剩余的参数转成数组 return function()&#123; // 返回一个新的函数 return self.apply( context, [].concat.call( args, [].slice.call( arguments ) ) ); // 执行新的函数的时候，会把之前传入的 context 当作新函数体内的 this // 并且组合两次分别传入的参数，作为新函数的参数 &#125;&#125;;var obj = &#123; name: 'sven'&#125;;var func = function( a, b, c, d )&#123;alert ( this.name ); // 输出： svenalert ( [ a, b, c, d ] ) // 输出： [ 1, 2, 3, 4 ]&#125;.bind( obj, 1, 2 );func( 3, 4 ); 总结this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。为了修正this的指向，可以使用call、apply来改变上下文，同时，call、apply也是对对象的一种扩展。 apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.hawuji.com/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.hawuji.com/tags/设计模式/"}]},{"title":"JavaScript设计模式与开发实践学习笔记01","date":"2017-03-04T15:47:49.000Z","path":"2017/03/04/JavaScript设计模式与开发实践学习笔记01/","text":"第一章 面向对象的JavaScript JavaScript是一门典型的动态类型语言，简单的理解动态类型编程语言就是变量的数据类型是不确定的，只有当程序运行到当前变量时才确定变量的类型。比如 var a = 123; 此时123既可能是string类型，也可能是number类型，只有在运行到a变量时才根据程序环境进行判断。 多态：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与 “可能改变的事物”分离开来。一段简单的多态代码1234567891011var makeSound = function( animal )&#123; if ( animal instanceof Duck )&#123; console.log( '嘎嘎嘎' ); &#125;else if ( animal instanceof Chicken )&#123; console.log( '咯咯咯' ); &#125;&#125;;var Duck = function()&#123;&#125;;var Chicken = function()&#123;&#125;;makeSound( new Duck() ); // 嘎嘎嘎makeSound( new Chicken() ); // 咯咯咯 上面这段代码实现了一个简单的多态，同一个函数传入不同的参数后输入不同的结果，但这段代码的问题在于如果要新加入一个不同的参数的话，函数maskSound就要扩充，当参数的种类越来越多时，maskSound函数也就变得越来越复杂。如：现在要加入一个dog参数，则makdSound函数就要再时行判断了。改进代码：12345678910111213var makeSound = function( animal )&#123; animal.sound();&#125;;var Duck = function()&#123;&#125;Duck.prototype.sound = function()&#123; console.log( '嘎嘎嘎' );&#125;;var Chicken = function()&#123;&#125;Chicken.prototype.sound = function()&#123; console.log( '咯咯咯' );&#125;;makeSound( new Duck() ); // 嘎嘎嘎makeSound( new Chicken() ); // 咯咯咯 如果此时要加入一个Dog则只需加入如下代码：12345var Dog = function()&#123;&#125;Dog.prototype.sound = function()&#123; console.log( '汪汪汪' );&#125;;makeSound( new Dog() ); // 汪汪汪 通过上面的两段代码就充分体现了多态背后的思想：将“做什么”和“谁去做以及怎样去做”分离开。 理解面向对象程序设计的多态，书中给出一个非常形象的比喻： 在电影的拍摄现场，当导演喊出“ action”时，主角开始背台词，照明师负责打灯光，后面的群众演员假装中枪倒地，道具师往镜头里撒上雪花。在得到同一个消息时，每个对象都知道自己应该做什么。 在程序设计中相似的例子，调用地图API，有时可能要调用谷歌地图，也有可能调用百度地图，如下的renderMap函数： 12345678910111213141516171819var googleMap = &#123; show: function()&#123; console.log( '开始渲染谷歌地图' ); &#125;&#125;;var baiduMap = &#123; show: function()&#123; console.log( '开始渲染百度地图' ); &#125;&#125;;var renderMap = function( type )&#123; if ( type === 'google' )&#123; googleMap.show(); &#125;else if ( type === 'baidu' )&#123; baiduMap.show(); &#125;&#125;;renderMap( 'google' ); // 输出：开始渲染谷歌地图renderMap( 'baidu' ); // 输出：开始渲染百度地图 上面的函数固然达到了多态的效果，但还是没有把多态的思想表达出来，如果此时要再加一个搜狗地图的话，又要修改renderMap函数了，因此还要修改这个renderMap函数，以达到更灵活的目的：1234567var renderMap = function( map )&#123; if ( map.show instanceof Function )&#123; map.show(); &#125;&#125;;renderMap( googleMap ); // 输出：开始渲染谷歌地图renderMap( baiduMap ); // 输出：开始渲染百度地图 如果此时加入一个搜狗地图刚只需添加123456var sosoMap = &#123; show: function()&#123; console.log( '开始渲染搜搜地图' ); &#125;&#125;;renderMap( sosoMap ); // 输出：开始渲染搜搜地 封装：在一些面向对象的高级语言中会用一些关键词如：private、public、 protected来实现数据的访问权限，但在JS中并没有这样的关键词去实现数据的封装，但可以通过函数来创建作用域。 原型模式实现关键，是语言本身是否提供了 clone 方法。ECMAScript 5 提供了 Object.create方法，可以用来克隆对象。代码如下：1234567891011var Plane = function()&#123; this.blood = 100; this.attackLevel = 1; this.defenseLevel = 1;&#125;;var plane = new Plane();plane.blood = 500;plane.attackLevel = 10;plane.defenseLevel = 7;var clonePlane = Object.create( plane );console.log( clonePlane ); // 输出： Object &#123;blood: 500, attackLevel: 10, defenseLevel: 7&#125; 在不支持 Object.create 方法的浏览器中，则可以使用以下代码：12345Object.create = Object.create || function( obj )&#123; var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125; 原型链：现在有一个根对象：Object,Object 是 Animal 的原型，而 Animal 是 Dog 的原型,这样他们之间就形成了一个原型链，当我们调用Dog中的某个方法时会先在Dog对象中寻找，如果Dog对象中没有则继续顺着原型链去Animal中寻到，如果还是没有刚继续到Object中寻找，如果找到刚返回，如果没有则返回null 所有的数据都是对象。 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。 对象会记住它的原型。 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。 ECMAScript 有 5 种原始类型（primitive type），即 Undefined、Null、Boolean、Number 和 String、Symbol 。基本类型包括 undefined、 number、 boolean、 string、 function、 object。 JavaScript 中的根对象是 Object.prototype 对象。 Object.prototype 对象是一个空的对象。我们在 JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的，Object.prototype 对象就是它们的原型。 1234var obj1 = new Object();var obj2 = &#123;&#125;;console.log( Object.getPrototypeOf( obj1 ) === Object.prototype ); // 输出： trueconsole.log( Object.getPrototypeOf( obj2 ) === Object.prototype ); // 输出： true JavaScript 给对象提供了一个名为proto的隐藏属性，某个对象的proto属性默认会指向它的构造器的原型对象，即{Constructor}.prototype。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.hawuji.com/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.hawuji.com/tags/设计模式/"},{"name":"原型模式","slug":"原型模式","permalink":"http://blog.hawuji.com/tags/原型模式/"}]},{"title":"Hexo入门介绍","date":"2017-01-10T13:01:34.000Z","path":"2017/01/10/hello-world/","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 使用方法创建一篇新文章可以执行下列命令来创建一篇新文章。1$ hexo new \"My New Post\" 查看文档: 写作 启动本地服务1$ hexo server Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用，查看文档: 服务器 生成文件1$ hexo generate 使用 Hexo 生成静态文件查看文档: 生成文件 一键部署1$ hexo deploy Hexo 提供了快速方便的一键部署功能，只需一条命令就能将网站部署到服务器上。查看文档: 部署","tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.hawuji.com/tags/hexo/"}]}]